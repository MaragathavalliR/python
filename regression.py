# -*- coding: utf-8 -*-
"""regression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RSG9b3hD09HNwcdQpt0QS_KaOdtihWib
"""

import numpy as np
import sklearn
import random
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt
import statsmodels.api as sm
import pandas as pd
import seaborn as sns
from sklearn.metrics import classification_report
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import StandardScaler

"""Linear Regression"""

x=2*np.random.rand(100,1)
y=4+3*x+np.random.randn(100,1)
plt.scatter(x,y)

lin_reg=LinearRegression()
lin_reg.fit(x,y)
new_x=np.random.rand(100,1)
y_pred = lin_reg.predict(x)
rmse = mean_squared_error(y, y_pred)
r2 = r2_score(y, y_pred)
print("r_squared=",r2)
print("rmse=",rmse)
lin_reg.intercept_,lin_reg.coef_

plt.scatter(x,y,color='blue')
plt.plot(x,y_pred,color='black')

x_mean = np.mean(x)
y_mean = np.mean(y)
numerator = np.sum((x - x_mean) * (y - y_mean))
denominator = np.sum((x - x_mean) ** 2)
slope = numerator / denominator
intercept = y_mean - slope * x_mean
predicted_y = slope * new_x + intercept
print("slope:",slope)
print("Intercept:",intercept)
#print("Predicted values: ",predicted_y)
rmse = mean_squared_error(y, predicted_y)
r2 = r2_score(y, predicted_y)
print("r_squared=",r2)
print("rmse=",rmse)

house=pd.read_csv("housing.csv")
house.isnull().sum()

house['total_bedrooms'].fillna(house['total_bedrooms'].mean(),inplace=True)
x_h=house[['longitude','latitude','housing_median_age','total_rooms','total_bedrooms','population','households','median_income']]
y_h=house['median_house_value']

X_train,X_test,Y_train,Y_test = train_test_split(x_h,y_h,test_size=0.25)
logr=LinearRegression().fit(X_train,Y_train)
pred_y=logr.predict(X_test)
rmse = mean_squared_error(Y_test, pred_y)
r2 = r2_score(Y_test, pred_y)
print("r_squared=",r2)
print("rmse=",rmse)

x_h=sm.add_constant(x_h)
model = sm.OLS(y_h, x_h).fit()
predictions = model.predict(x_h)
model.summary()

"""Logistic regression"""

x=np.linspace(0,100.0,num=10).reshape(-1,1)
y=[random.randint(0, 1) for i in range(10)]
x1=np.linspace(0,100.0,num=10).reshape(-1,1)
logr=LogisticRegression().fit(x,y)
prob=logr.predict_proba(x1)
predicted = logr.predict(x1)
print(predicted)
print(prob)
score = logr.score(x,y)
score

diabetes=pd.read_csv("diabetes.csv")
diabetes.info()

y=diabetes['Outcome']
x=diabetes.drop('Outcome',axis=1)
trainx,testx,trainy,testy=train_test_split(x,y,test_size=0.3)
scaler=MinMaxScaler()
trainx=scaler.fit_transform(trainx)
testx=scaler.transform(testx)
logr=LogisticRegression().fit(trainx,trainy)
predy=logr.predict(testx)
print(classification_report(testy, predy))

import random
a=[random.randint(20,40) for i in range(1000)]
b=[random.randint(10000,50000) for i in range(1000)]
c=[random.randint(0, 1) for i in range(1000)]
cust=pd.DataFrame({'Age':a,'income':b,'bought magazine': c})
cust

y=cust['bought magazine']
x=cust.drop('bought magazine',axis=1)
trainx,testx,trainy,testy=train_test_split(x,y,test_size=0.25)
logr=LogisticRegression().fit(trainx,trainy)
predy=logr.predict(testx)
print(classification_report(testy, predy))

bank=pd.read_csv("bank-additional-full.csv",sep=";")
bank.head()

bank.info()

categorical_cols = ['job', 'marital', 'education', 'default', 'housing', 'loan','contact','month', 'day_of_week', 'poutcome']
numeric_cols = ['age', 'duration', 'campaign', 'pdays', 'previous', 'emp.var.rate', 'cons.price.idx', 'cons.conf.idx', 'euribor3m', 'nr.employed']
bank = pd.get_dummies(bank, columns=categorical_cols)
scaler = StandardScaler()
bank[numeric_cols] = scaler.fit_transform(bank[numeric_cols])
X_train, X_test, y_train, y_test = train_test_split(bank.drop('y', axis=1), bank['y'], test_size=0.2, random_state=42)
model = LogisticRegression()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

print(classification_report(y_test,y_pred))